---
title: Medium | Unique Binary Search Tree II
tags:
  - tricky
categories:
  - Leetcode
  - Backtracking
date: 2020-05-20 20:11:23
---

Given an integer *n*, generate all structurally unique **BST's** (binary search trees) that store values 1 ... *n*.

[Leetcode](https://leetcode.com/problems/unique-binary-search-trees-ii/)

<!--more-->

**Example:**

```
Input: 3
Output:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
Explanation:
The above output corresponds to the 5 unique BST's shown below:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

---

#### Tricky 

How to construct a BST from 1..n? We could try all possible integers between `[1, n]` as root of tree, then the left subtrees will contain integers between `[1, k - 1]`, the right subtrees will contain integers between `[k + 1, n]`.

How to solve it using DP? We could find two subtrees generated with same length integers but different start index will have same number of structurely BSTs. 

For example, subtrees generated with integers between `[i, i + len]` and subtrees with integers between `[j, j + len]` have same number of structurely BSTs. The only difference between them is the values in each node have an offset changed.

We could store the BSTs with different length generated by integers between `[1, k]` in a DP[n].

And we  can clone a list of BST with same length generated by integers between `[1 + offset, k + offset]`.

---

#### My thoughts 

Recursively generate BSTs with integers between `[start, end]`.

---

#### Recursion

```java
class Solution {
    public List<TreeNode> generateTrees(int n) {
        List<TreeNode> res = new ArrayList<>();
        if (n == 0) return res;
        return printTrees(1, n);
    }
    
    private List<TreeNode> printTrees(int start, int end) {
        List<TreeNode> res = new ArrayList<>();
        if (start > end) {
            res.add(null);
            return res;
        }
        for (int root = start; root <= end; root++) {
            List<TreeNode> lnodes = printTrees(start, root - 1);
            List<TreeNode> rnodes = printTrees(root + 1, end);
            for (TreeNode lnode : lnodes) {
                for (TreeNode rnode : rnodes) {
                    TreeNode r = new TreeNode(root);
                    r.left = lnode;
                    r.right = rnode;
                    res.add(r);
                }
            }
        }
        return res;
    }
}
```

T: O(2^n)			S: O(2^n)

---

#### DP

Using DP means you are reusing Subtree[start, end] solution, which means if two unique BST both contains Subtree[3, 5], you are using the same saved subtree in two different BST. It is not a completely deep copy.

So we need to deep copy BSTs with offset.

```java
class Solution {
    public List<TreeNode> generateTrees(int n) {
        List<TreeNode> res = new ArrayList<>();
        if (n == 0) return res;
        List<TreeNode>[] dp = new List[n + 1];
        List<TreeNode> list0 = new ArrayList<>();
        list0.add(null);
        dp[0] = list0;
        for (int len = 1; len <= n; len++) {
            List<TreeNode> list = new ArrayList<>();
            for (int left = 0; left < len; left++) {  // leftnodes number is between [0, len - 1]
                int root = left + 1;
                List<TreeNode> lnodes = dp[left];
                List<TreeNode> rnodes = dp[len - left - 1];
                for (TreeNode lnode : lnodes) {
                    for (TreeNode rnode : rnodes) {
                        TreeNode r = new TreeNode(root);
                        r.left = lnode;
                        r.right = clone(rnode, root);
                        list.add(r);
                    }
                }
            }
            dp[len] = list;
        }
        return dp[n];
    }
    // deep copy a BST with offset.
    private TreeNode clone(TreeNode n, int offset) {
        if (n == null) {
            return null;
        }
        TreeNode res = new TreeNode(n.val + offset);
        res.left = clone(n.left, offset);
        res.right = clone(n.right, offset);
        return res;
    } 
}
```

T: O(n^2)		S: O(n)

---

#### Summary 

In tricky.